; References:
;   https://www.smspower.org/Development/SN76489, which links to:
;   https://www.smspower.org/forums/9686-VoiceEmulationOnTheSMS#44103
;   which is offline but has been forked and tweaked:
;   https://github.com/maxim-zhao/wav_to_psg

; System VIA addresses needed to talk to the sound chip.
system_via_outb = $fe40
system_via_outa = $fe41
system_via_ddra = $fe43

; User VIA addresses needed for timer interrupts.
user_via_t1c_l = $fe64
user_via_t1c_h = $fe65
user_via_t1l_l = $fe66
user_via_t1l_h = $fe67
user_via_acr = $fe6b
user_via_ifr = $fe6d
user_via_ier = $fe6e

; SN76489 constants.
sn_latch_tone    = %1000 << 4
sn_latch_volume  = %1001 << 4
sn_channel_shift = 5
sn_channel_0     = 0 << sn_channel_shift ; 0 is a tone channel in hardware, unlike OS where 0 is noise
sn_channel_1     = 1 << sn_channel_shift
sn_channel_2     = 2 << sn_channel_shift
sn_channel_3     = 3 << sn_channel_shift

; Frequency control: VIA is clocked at 1MHz and we need to subtract 2 to allow
; for the time taken to load the counter from the latch.
sample_rate = 8000 ; SFTODO 8000 ; Hz
timer_value = (1000000 / sample_rate) - 2

os_irq_a = $fc
irq1v = $204

; A macro for use after performance-critical branch instructions to check that
; no page-crossing penalty is incurred.
; TODO: maybe create things like "fast_beq target" macros which wrap beq+check_no_page_crossing
macro check_no_page_crossing target
    assert hi(*) == hi(target)
endmacro

macro write_a_to_slow_databus
    ; Put the value in A on the slow databus.
    sta system_via_outa
    ; Use the addressable latch to toggle the sound chip write pin. See AUG
    ; section 23.2; the value we write to system_via_outb is %(PB3 PB2 PB1 PB0):
    ; - (PB2 PB1 PB0) selects one of the eight latch output bits;
    ;   %000 = SN76489 write enable
    ; - PB3 is the bit to write.
    ldy #%0000
    sty system_via_outb
    ; We need 8us or 16 cycles between the two writes.
    php        ; 3 cycles
    plp        ; 4 cycles
    php        ; 3 cycles
    plp        ; 4 cycles
    ldy #%1000 ; 2 cycles
    sty system_via_outb
endmacro

    org $2000

    ; TODO: Right now, this *works* on BeebEm (albeit the sample slows noticeably if you type) but
    ; on b-em it plays OK but the keyboard is totally unresponsive. This suggests I'm doing something
    ; wrong/iffy with interrupts.
.start
    ; Set tone for channels 0-2 to 1. smspower.org says this can be 0 or 1, but
    ; advice from tricky on stardot suggests this has to be 1 on the Beeb. TODO:
    ; I haven't actually tried 0, but since I'm using emulators it's possible 0
    ; would work there but not on real hardware.
    lda #sn_latch_tone or sn_channel_0 or 1 ; low bits of tone are 1
.set_tone_loop
    pha
    jsr write_a
    lda #0 ; high bits of tone are 0
    jsr write_a
    pla
    clc
    adc #1<<sn_channel_shift
    cmp #sn_latch_tone or sn_channel_3 or 1
    bne set_tone_loop

    ; Patch self-modifying code with initial values: start playing the high
    ; nybble of the first byte of the sample on channel 0.
    lda #<sample
    sta ptr
    lda #>sample
    sta ptr+1
    lda #lo(high_nybble)
    sta jmp_abs_low_or_high_nybble+1
    lda #sn_latch_volume or sn_channel_0
    sta current_channel

    sei

    ; Install our interrupt handler.
    lda irq1v
    sta jmp_parent_irq_handler+1
    lda irq1v+1
    sta jmp_parent_irq_handler+2
    lda #<our_irq_handler
    sta irq1v
    lda #>our_irq_handler
    sta irq1v+1

    ; Set initial user VIA timer 1 value. TODO: Do we need to do this? Probably...
    ; Set user VIA timer 1 latches at the same time so the interrupts recur.
    lda #<timer_value
    sta user_via_t1c_l
    sta user_via_t1l_l
    lda #>timer_value
    sta user_via_t1c_h
    sta user_via_t1l_h

    ; Set user VIA timer 1 to free run/continuous mode generating interrupts.
    lda #%01000000
    sta user_via_acr

    ; Enable user VIA timer 1 interrupt.
    lda #%11000000
    sta user_via_ier

    cli
    rts


    ; This does *not* preserve X, so we mustn't touch it.
    ; TODO: Can I avoid touching Y too?
.our_irq_handler
    ; An interrupt has occurred; is it timer 1?
    bit user_via_ifr
    bpl not_timer_1_interrupt

    ; Yes, it is. Save the value of A saved by the OS on the stack.
    ; TODO: Can we get away without doing this, since interrupts are disabled all the time we're running?!
    lda os_irq_a
    pha

    ; Clear timer 1 interrupt flag.
    lda user_via_t1c_l

    ; Save Y.
    tya
    pha

    ; Set slow databus up for write.
    ; TODO: We may be able to avoid doing this every time, but probably safest not to.
    ; TODO: Have temp factored this out of write_a macro so we can do it here before A
    ; contains anything valuable, but if it turns out we need to allow X or Y to be
    ; corrupted anyway there's no real value in this.
    lda #$ff
    sta system_via_ddra

    ; Play the next part of the sample.
.lda_abs_ptr
ptr = lda_abs_ptr+1
    lda $ffff ; patched at runtime
.jmp_abs_low_or_high_nybble
    assert hi(high_nybble) = hi(low_nybble)
    jmp high_nybble ; low byte of operand patched at runtime
.high_nybble
    lsr a
    lsr a
    lsr a
    lsr a
    ldy #lo(low_nybble)
    sty jmp_abs_low_or_high_nybble+1
    bne got_nybble ; always branch
    check_no_page_crossing got_nybble
.low_nybble
    and #%1111
    ldy #lo(high_nybble)
    sty jmp_abs_low_or_high_nybble+1
    inc ptr
    bne got_nybble
    check_no_page_crossing got_nybble
    inc ptr+1
    ldy ptr+1
    ; TODO: We're assuming samples always end on a page boundary here; we don't actually ensure this yet.
    ; (Note that we don't assume this currently for sample start, so an arbitrary length sample can be
    ; played precisely by starting it at the right offset. We don't take advantage of this either!)
    cpy #>sample_end
    beq at_sample_end
.got_nybble
.ora_imm_latch_volume_channel
current_channel = ora_imm_latch_volume_channel+1
    ora #$ff ; patched at runtime
    write_a_to_slow_databus ; TODO: trying to avoid subroutine overhead, worth it? also allows me to avoid redundant (?) faffing with I flag - I believe here in interrupt handler, we *know* I is set

    ; Advance current channel, wrapping back to sn_channel_0 after sn_channel_2.
    lda current_channel
    cmp #sn_latch_volume or sn_channel_2
    bcc no_channel_wrap
    check_no_page_crossing no_channel_wrap
    lda #((sn_latch_volume or sn_channel_0) - (1<<sn_channel_shift) - 1) and &ff ; we subtract 1 because C is set
.no_channel_wrap
    adc #1<<sn_channel_shift
    sta current_channel

.finish_timer_1_handler
    ; Restore Y.
    pla
    tay

    ; Restore the value of A saved by the OS from the stack.
    pla
    sta os_irq_a

    ; Just rti; this is our interrupt and we don't want to waste time having the OS do anything else with it.
    rti

.not_timer_1_interrupt
.jmp_parent_irq_handler
    jmp $ffff ; patched during initialisation

.at_sample_end
if FALSE ; TODO: this code stops sample playback and may be useful, for but now I want to loop the sample for ease of testing
    ; Remove our claim on the IRQ handler now we've finished.
    sei
    lda jmp_parent_irq_handler+1
    sta irq1v
    lda jmp_parent_irq_handler+2
    sta irq1v+1
    cli

    ; Disable user VIA timer 1 interrupt now we no longer need it.
    lda #%01000000
    sta user_via_ier
else
    ; TODO: copy and paste of code from "start"; should factor out in a proper version.
    lda #<sample
    sta ptr
    lda #>sample
    sta ptr+1
    lda #lo(high_nybble)
    sta jmp_abs_low_or_high_nybble+1
    lda #sn_latch_volume or sn_channel_0
    sta current_channel
endif

    jmp finish_timer_1_handler


; Write the byte in A to the sound chip (via the slow databus). Unlike the
; macro, this explicitly disables and re-enables interrupts; the AUG says we
; must do all slow databus access with interrupts disabled.
.write_a
    sei
    ; Set slow databus up for write.
    ; TODO: We may be able to avoid doing this every time, but probably safest not to.
    ldy #$ff
    sty system_via_ddra

    write_a_to_slow_databus
    cli
    rts


    ; Our samples are 4-bit values packed into bytes with the first value in the
    ; high bits.
.sample
    ; incbin "sine-440hz-8khz-mono.wav.psg.bin"
    ; incbin "brush-strokes-8khz-mono.wav.psg.bin"
    incbin "brush-strokes-8khz-mono.wav.pcmenc"
.sample_end

.end

save "test", start, end
