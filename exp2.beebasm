; References:
;   https://www.smspower.org/Development/SN76489, which links to:
;   https://www.smspower.org/forums/9686-VoiceEmulationOnTheSMS#44103
;   which is offline but has been forked and tweaked:
;   https://github.com/maxim-zhao/wav_to_psg

ptr = $70
current_nybble = $72
current_channel = $73

; System VIA addresses needed to talk to the sound chip.
via_outb = $fe40
via_outa = $fe41
via_ddra = $fe43

; SN76489 constants.
sn_latch_tone    = %1000 << 4
sn_latch_volume  = %1001 << 4
sn_channel_0     = 0 << 5 ; 0 is a tone channel in hardware, unlike OS where 0 is noise
sn_channel_1     = 1 << 5
sn_channel_2     = 2 << 5

; A macro for use after performance-critical branch instructions to check that
; no page-crossing penalty is incurred.
; TODO: maybe create things like "fast_beq target" macros which wrap beq+check_no_page_crossing
macro check_no_page_crossing target
    assert hi(*) == hi(target)
endmacro

    org $2000

.start
    ; AUG says we must do all slow databus acccess with interrupts disabled.
    sei

    ; Set slow databus up for write.
    lda #$ff
    sta via_ddra

    ; Set channel 0's tone to 1. smspower.org says this can be 0 or 1, but advice from tricky
    ; on stardot suggests this has to be 1 on the Beeb. TODO: I haven't actually tried 0,
    ; but since I'm using emulators it's possible 0 would work there but not on real hardware.
    lda #sn_latch_tone or sn_channel_0 or 1 ; low bits of tone are 1
    jsr write_a
    lda #0 ; high bits of tone are 0
    jsr write_a
    ; TODO: Using a loop would be neater but just hacking for now.
    lda #sn_latch_tone or sn_channel_1 or 1 ; low bits of tone are 1
    jsr write_a
    lda #0 ; high bits of tone are 0
    jsr write_a
    lda #sn_latch_tone or sn_channel_2 or 1 ; low bits of tone are 1
    jsr write_a
    lda #0 ; high bits of tone are 0
    jsr write_a

    ; current_nybble toggles between 63 and 64 so we can test it with BIT and
    ; get the result in V.
    lda #63
    sta current_nybble
    lda #sn_channel_0
    sta current_channel

    ; TODO: We may want to use Y to iterate through a page at a time, and/or to page-align
    ; the sample. Let's not worry about it for the moment until I see how timings work.
    lda #<sample
    sta ptr
    lda #>sample
    sta ptr+1
.loop
    ; TODO: Could we save a few cycles by doing lda #0:bne low_nybble and inc/decing lda # operand? we'd have to repeat the lda (ptr),y instruction though. then again, *if* we're corrupting Y anyway we could maybe use ldy #imm here, and have a single lda abs which is self-modified before it to do the load.
    ; TODO: Could just use self-modifying "lda abs" if easier/faster
    ldy #0
    lda (ptr),y
    bit current_nybble
    bvs low_nybble
    check_no_page_crossing low_nybble
    lsr a
    lsr a
    lsr a
    lsr a
    inc current_nybble ; set to 64 so "bit" will set V when testing
    bvc got_nybble ; always branch
    check_no_page_crossing got_nybble
.low_nybble
    and #%1111
    dec current_nybble ; set to 63 so "bit" will clear V when testing
    inc ptr
    bne got_nybble
    check_no_page_crossing got_nybble
    inc ptr+1
    ldy ptr+1
    ; TODO: We're assuming samples always end on a page boundary here; we don't actually ensure this yet.
    ; (Note that we don't assume this currently for sample start, so an arbitrary length sample can be
    ; played precisely by starting it at the right offset. We don't take advantage of this either!)
    cpy #>sample_end
    beq at_sample_end
.got_nybble
    ora #sn_latch_volume
    ora current_channel
    jsr write_a

    ; Advance current_channel, wrapping back to sn_channel_0 after sn_channel_2.
    ; 3+2+0.666*3+0.333*(2+2)+2+3=13.333 cycles
    lda current_channel
    cmp #sn_channel_2
    bcc no_channel_wrap
    check_no_page_crossing no_channel_wrap
    lda #(sn_channel_0-(1<<5)-1) and &ff ; we subtract 1 because C is set
.no_channel_wrap
    adc #1<<5
    sta current_channel

    jsr delay
    jmp loop

.at_sample_end
    ; Re-enable interrupts and return control.
    cli
    rts

; Write the byte in A to the sound chip (via the slow databus).
; TODO: Haven't adjusted any of the delay looks to allow for overhead now this is a subroutine
.write_a
    ; Put the value in A on the slow databus.
    sta via_outa
    ; Use the addressable latch to toggle the sound chip write pin. See AUG
    ; section 23.2; the value we write to via_outb is %(PB3 PB2 PB1 PB0):
    ; - (PB2 PB1 PB0) selects one of the eight latch output bits;
    ;   %000 = SN76489 write enable
    ; - PB3 is the bit to write.
    ldx #%0000
    stx via_outb
    ; https://github.com/crtc-demos/bbc-teletext-video-player/blob/master/teletext/audio/aplay.a65
    ; says we need at least 8us delay here. TODO: tricky's code seems to use a tighter actual 8us
    ; delay, which may be better - particularly if we're called by interrupts and a delay holds up
    ; foreground task a bit longer.
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    ldx #%1000
    stx via_outb
    rts


    ; TODO: This is a super crude delay loop to give *approximately* 8kHz playback. Be more careful here
    ; once things are working properly. (Though if we are working with interrupts, a certain amount of
    ; jitter will be outside our control but we probably get called at a consistent rate without any
    ; further effort. Speculation!)
.delay
    ; On a *really* rough calculation, writing the two 4-bit values packed into a byte takes 90 cycles,
    ; so let's say there are 45 cycles of overhead per value. OK, now an extra 7*3 since I've added nops. With a 2MHz clock and an 8kHz sample rate
    ; we need to write a sample every 250 cycles, so we need to burn about 205 cycles here. This is all
    ; so rough and ready that the '5' is excess precision... With nops, 205-21=184-ish.
    ldx #37 ; 37*5 cycles per loop=185ish
.delay_loop
    dex
    bne delay_loop
    assert hi(P%) == hi(delay_loop) ; we don't want a page-crossing penalty TODO: check this is right way to check!
    rts

    ; wav_to_psg packs 4-bit values into bytes with the first value in the high bits.
.sample
    ; incbin "sine-440hz-8khz-mono.wav.psg.bin"
    ; incbin "brush-strokes-8khz-mono.wav.psg.bin"
    incbin "brush-strokes-8khz-mono.wav.pcmenc"
.sample_end

.end

save "test", start, end
