; References:
;   https://www.smspower.org/Development/SN76489, which links to:
;   https://www.smspower.org/forums/9686-VoiceEmulationOnTheSMS#44103
;   which is offline but has been forked and tweaked:
;   https://github.com/maxim-zhao/wav_to_psg

opcode_clc = $18
opcode_sec = $38

; System VIA addresses needed to talk to the sound chip.
via_outb = $fe40
via_outa = $fe41
via_ddra = $fe43

; SN76489 constants.
sn_latch_tone    = %1000 << 4
sn_latch_volume  = %1001 << 4
sn_channel_shift = 5
sn_channel_0     = 0 << sn_channel_shift ; 0 is a tone channel in hardware, unlike OS where 0 is noise
sn_channel_1     = 1 << sn_channel_shift
sn_channel_2     = 2 << sn_channel_shift
sn_channel_3     = 3 << sn_channel_shift

; A macro for use after performance-critical branch instructions to check that
; no page-crossing penalty is incurred.
; TODO: maybe create things like "fast_beq target" macros which wrap beq+check_no_page_crossing
macro check_no_page_crossing target
    assert hi(*) == hi(target)
endmacro

    org $2000

.start
    ; AUG says we must do all slow databus acccess with interrupts disabled.
    sei

    ; Set slow databus up for write.
    lda #$ff
    sta via_ddra

    ; Set tone for channels 0-2 to 1. smspower.org says this can be 0 or 1, but
    ; advice from tricky on stardot suggests this has to be 1 on the Beeb. TODO:
    ; I haven't actually tried 0, but since I'm using emulators it's possible 0
    ; would work there but not on real hardware.
    lda #sn_latch_tone or sn_channel_0 or 1 ; low bits of tone are 1
.set_tone_loop
    pha
    jsr write_a
    lda #0 ; high bits of tone are 0
    jsr write_a
    pla
    clc
    adc #1<<sn_channel_shift
    cmp #sn_latch_tone or sn_channel_3 or 1
    bne set_tone_loop

    lda #opcode_clc
    sta current_nybble_clc_or_sec
    lda #sn_latch_volume or sn_channel_0
    sta current_channel

    lda #<sample
    sta ptr
    lda #>sample
    sta ptr+1
.loop
.lda_abs_ptr
ptr = lda_abs_ptr+1
    lda $ffff ; patched at runtime
.current_nybble_clc_or_sec
    brk ; patched at runtime
    bcs low_nybble
    check_no_page_crossing low_nybble
    lsr a
    lsr a
    lsr a
    lsr a
    ldy #opcode_sec
    sty current_nybble_clc_or_sec
    bne got_nybble ; always branch
    check_no_page_crossing got_nybble
.low_nybble
    and #%1111
    ldy #opcode_clc
    sty current_nybble_clc_or_sec
    inc ptr
    bne got_nybble
    check_no_page_crossing got_nybble
    inc ptr+1
    ldy ptr+1
    ; TODO: We're assuming samples always end on a page boundary here; we don't actually ensure this yet.
    ; (Note that we don't assume this currently for sample start, so an arbitrary length sample can be
    ; played precisely by starting it at the right offset. We don't take advantage of this either!)
    cpy #>sample_end
    beq at_sample_end
.got_nybble
.ora_imm_latch_volume_channel
current_channel = ora_imm_latch_volume_channel+1
    ora #$ff ; patched at runtime
    jsr write_a

    ; Advance current channel, wrapping back to sn_channel_0 after sn_channel_2.
    lda current_channel
    cmp #sn_latch_volume or sn_channel_2
    bcc no_channel_wrap
    check_no_page_crossing no_channel_wrap
    lda #((sn_latch_volume or sn_channel_0) - (1<<sn_channel_shift) - 1) and &ff ; we subtract 1 because C is set
.no_channel_wrap
    adc #1<<sn_channel_shift
    sta current_channel

    jsr delay
    jmp loop

.at_sample_end
    ; Re-enable interrupts and return control.
    cli
    rts

; Write the byte in A to the sound chip (via the slow databus).
; TODO: Haven't adjusted any of the delay looks to allow for overhead now this is a subroutine
.write_a
    ; Put the value in A on the slow databus.
    sta via_outa
    ; Use the addressable latch to toggle the sound chip write pin. See AUG
    ; section 23.2; the value we write to via_outb is %(PB3 PB2 PB1 PB0):
    ; - (PB2 PB1 PB0) selects one of the eight latch output bits;
    ;   %000 = SN76489 write enable
    ; - PB3 is the bit to write.
    ldx #%0000
    stx via_outb
    ; We need 8us or 16 cycles between the two writes.
    php        ; 3 cycles
    plp        ; 4 cycles
    php        ; 3 cycles
    plp        ; 4 cycles
    ldx #%1000 ; 2 cycles
    stx via_outb
    rts


    ; TODO: This is a super crude delay loop to give *approximately* 8kHz playback. Be more careful here
    ; once things are working properly. (Though if we are working with interrupts, a certain amount of
    ; jitter will be outside our control but we probably get called at a consistent rate without any
    ; further effort. Speculation!)
.delay
    ; On a *really* rough calculation, writing the two 4-bit values packed into a byte takes 90 cycles,
    ; so let's say there are 45 cycles of overhead per value. OK, now an extra 7*3 since I've added nops. With a 2MHz clock and an 8kHz sample rate
    ; we need to write a sample every 250 cycles, so we need to burn about 205 cycles here. This is all
    ; so rough and ready that the '5' is excess precision... With nops, 205-21=184-ish.
    ldx #37 ; 37*5 cycles per loop=185ish
.delay_loop
    dex
    bne delay_loop
    assert hi(P%) == hi(delay_loop) ; we don't want a page-crossing penalty TODO: check this is right way to check!
    rts

    ; wav_to_psg packs 4-bit values into bytes with the first value in the high bits.
.sample
    ; incbin "sine-440hz-8khz-mono.wav.psg.bin"
    ; incbin "brush-strokes-8khz-mono.wav.psg.bin"
    incbin "brush-strokes-8khz-mono.wav.pcmenc"
.sample_end

.end

save "test", start, end
